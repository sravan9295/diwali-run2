<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü™î Diwali Night Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: white;
            overflow: hidden;
            position: fixed;
            touch-action: none;
        }

        /* Remove all scrollbars */
        ::-webkit-scrollbar {
            display: none;
        }
        
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .game-stats {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            background: rgba(0, 0, 0, 0.85);
            padding: clamp(10px, 3vw, 15px);
            border-radius: clamp(10px, 3vw, 15px);
            border: 2px solid rgba(255, 107, 53, 0.3);
            pointer-events: auto;
            font-size: clamp(14px, 3.5vw, 16px);
            line-height: 1.4;
            backdrop-filter: blur(10px);
            z-index: 200;
        }

        .game-controls {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            display: flex;
            gap: clamp(8px, 2vw, 10px);
            pointer-events: auto;
            z-index: 200;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b35, #ffaa00);
            color: white;
            border: none;
            padding: clamp(10px, 3vw, 12px) clamp(16px, 4vw, 20px);
            border-radius: clamp(8px, 2.5vw, 12px);
            font-weight: bold;
            font-size: clamp(14px, 3.5vw, 16px);
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            min-height: 44px;
            /* iOS touch target minimum */
            min-width: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover,
        .btn:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.5);
        }

        .btn:active {
            transform: translateY(0px);
        }

        .start-screen,
        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            padding: clamp(20px, 5vw, 40px);
            border-radius: clamp(15px, 4vw, 20px);
            border: 2px solid rgba(255, 107, 53, 0.3);
            pointer-events: auto;
            backdrop-filter: blur(15px);
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: hidden;
            z-index: 300;
        }

        .start-screen h1 {
            font-size: clamp(1.8rem, 6vw, 2.5rem);
            background: linear-gradient(45deg, #ff6b35, #ffaa00, #ff1493);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: clamp(15px, 4vw, 20px);
            line-height: 1.2;
        }

        .game-over-screen {
            display: none;
        }

        .game-over-screen h2 {
            font-size: clamp(1.5rem, 5vw, 2rem);
            color: #ff6b35;
            margin-bottom: clamp(10px, 3vw, 15px);
        }

        .game-over-screen h3 {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            color: #ffaa00;
            margin-bottom: clamp(15px, 4vw, 20px);
        }

        .instructions {
            margin: clamp(15px, 4vw, 20px) 0;
            line-height: 1.6;
            color: #d1d5db;
            font-size: clamp(14px, 3.5vw, 16px);
            text-align: left;
        }

        .instructions p {
            margin-bottom: clamp(8px, 2vw, 10px);
        }

        .instructions strong {
            color: #ff6b35;
        }

        .mobile-controls {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 0);
            left: 0;
            width: 100%;
            height: clamp(200px, 35vh, 300px);
            display: none;
            pointer-events: auto;
            z-index: 150;
            opacity: 0;
            /* Hide visual indicators but keep touch areas */
        }

        .control-area {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 4vw, 18px);
            font-weight: bold;
            color: transparent;
            /* Hide text */
            border: none;
            /* Hide borders */
            background: transparent;
            /* Hide background */
            backdrop-filter: none;
            transition: all 0.2s;
            user-select: none;
        }

        .control-area:active {
            background: rgba(255, 107, 53, 0.1);
            /* Subtle feedback on touch */
            transform: scale(0.98);
        }

        .jump-area {
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            border-radius: 0 0 0 0;
        }

        .move-left {
            bottom: 0;
            left: 0;
            width: 50%;
            height: 50%;
            border-radius: 0 0 0 clamp(15px, 4vw, 20px);
            border-right: 1px dashed rgba(255, 107, 53, 0.4);
        }

        .move-right {
            bottom: 0;
            right: 0;
            width: 50%;
            height: 50%;
            border-radius: 0 0 clamp(15px, 4vw, 20px) 0;
            border-left: 1px dashed rgba(255, 107, 53, 0.4);
        }

        /* Mobile Detection and Responsive Design */
        @media (max-width: 768px),
        (hover: none) {
            .mobile-controls {
                display: block;
                opacity: 0;
                /* Keep invisible but functional */
            }

            .game-stats {
                font-size: 14px;
                padding: 10px;
            }

            .start-screen,
            .game-over-screen {
                padding: 20px;
                margin: 10px;
            }
        }

        @media (max-height: 600px) {
            .mobile-controls {
                height: 40vh;
            }

            .start-screen,
            .game-over-screen {
                max-height: 80vh;
                padding: 15px;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            .mobile-controls {
                height: 50vh;
            }

            .game-stats {
                top: 10px;
                left: 10px;
                padding: 8px;
                font-size: 12px;
            }

            .game-controls {
                top: 10px;
                right: 10px;
            }
        }

        /* üõ†Ô∏è Development Features Styles */
        .dev-panel {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.95);
            padding: 12px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 0, 0.4);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00ff00;
            pointer-events: auto;
            z-index: 250;
            min-width: 160px;
            backdrop-filter: blur(15px);
            box-shadow: 0 4px 20px rgba(0, 255, 0, 0.2);
        }

        .fps-counter {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fps-value {
            font-size: 18px;
            min-width: 45px;
            text-align: right;
        }

        .fps-bar {
            width: 60px;
            height: 4px;
            background: rgba(0, 255, 0, 0.2);
            border-radius: 2px;
            margin-left: 8px;
            overflow: hidden;
        }

        .fps-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88);
            border-radius: 2px;
            transition: width 0.1s ease;
        }

        .dev-stats {
            line-height: 1.3;
            font-size: 11px;
            color: #88ff88;
        }

        .dev-toggle {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            border: 2px solid rgba(0, 255, 0, 0.4);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 250;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .dev-toggle:hover {
            background: rgba(0, 50, 0, 0.9);
            border-color: rgba(0, 255, 0, 0.6);
            transform: translateX(-50%) scale(1.05);
        }

        /* Hide dev features on mobile by default */
        @media (max-width: 768px) {
            .dev-panel {
                bottom: 10px;
                right: 10px;
                font-size: 10px;
                padding: 8px;
                min-width: 120px;
            }

            .dev-toggle {
                top: 50px;
                font-size: 10px;
                padding: 4px 8px;
            }
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <!-- Game Stats -->
        <div class="game-stats" id="gameStats" style="display: none;">
            <div id="score">üéÜ Score: 0</div>
            <div id="lives">‚ù§Ô∏è Lives: 3</div>
            <div id="speed">‚ö° Speed: 10</div>
        </div>

        <!-- Game Controls -->
        <div class="game-controls" id="gameControls" style="display: none;">
            <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
        </div>

        <!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <h1>ü™î Diwali Night Runner</h1>
            <div class="instructions">
                <p><strong>Controls:</strong></p>
                <p>‚Üë or Space: Jump</p>
                <p>‚Üê or A: Move Left</p>
                <p>‚Üí or D: Move Right</p>
                <br>
                <p><strong>üéÜ Collectibles:</strong></p>
                <p>ü™î Diya: +25 points</p>
                <p>‚ú® Sparkler: +15 points</p>
                <p>üå∏ Rangoli: +30 points</p>
                <p>ü™ô Coin: +10 points</p>
            </div>
            <button class="btn" id="startBtn">üéÆ Start Game</button>
        </div>

        <!-- Game Over Screen -->
        <div class="game-over-screen" id="gameOverScreen">
            <h2>üéÜ Game Over!</h2>
            <h3 id="finalScore">Final Score: 0</h3>
            <button class="btn" id="restartBtn">üîÑ Play Again</button>
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div class="control-area jump-area" id="jumpArea">ü™î TAP TO JUMP</div>
            <div class="control-area move-left" id="moveLeft">‚Üê LEFT</div>
            <div class="control-area move-right" id="moveRight">RIGHT ‚Üí</div>
        </div>

        <!-- üõ†Ô∏è Development Panel -->
        <div class="dev-toggle" id="devToggle" style="display: none;">DEV</div>
        <div class="dev-panel" id="devPanel" style="display: none;">
            <div class="fps-counter" id="fpsCounter">
                <span>FPS:</span>
                <div style="display: flex; align-items: center;">
                    <span class="fps-value" id="fpsValue">--</span>
                    <div class="fps-bar">
                        <div class="fps-fill" id="fpsFill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="dev-stats" id="devStats">
                <div>Objects: <span id="objectCount">0</span></div>
                <div>Triangles: <span id="triangleCount">0</span></div>
                <div>Memory: <span id="memoryUsage">--</span></div>
                <div>Profile: <span id="deviceProfile">--</span></div>
                <div>Frame Time: <span id="frameTime">--</span>ms</div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.169.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Game State
        const gameState = {
            isPlaying: false,
            isPaused: false,
            score: 0,
            speed: 10,
            lives: 3,
            gameOver: false,
            highScore: parseInt(localStorage.getItem('diwaliRunnerHighScore') || '0')
        };

        // üõ†Ô∏è DEVELOPMENT FEATURES (Easy to toggle on/off)
        const DEV_CONFIG = {
            showFPS: true,           // Show real-time FPS counter (capped at 120)
            showStats: true,         // Show performance stats
            showCollisionBoxes: false, // Show collision wireframes
            showDebugInfo: true,     // Show debug information
            enableConsoleLog: true,  // Enable detailed console logging
            showCameraHelper: false, // Show camera helper lines
            godMode: false,          // Invincibility mode
            slowMotion: false,       // Slow motion mode (0.5x speed)
            fpsUpdateRate: 100       // Update FPS every 100ms for real-time display
        };

        // Device Detection and Performance Settings
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEnd = navigator.hardwareConcurrency <= 4 || navigator.deviceMemory <= 4;
        const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2);

        // Performance settings based on device
        const performanceSettings = {
            shadowsEnabled: !isMobile && !isLowEnd,
            particleCount: isMobile ? 0.5 : isLowEnd ? 0.7 : 1.0,
            antialias: !isMobile,
            maxLights: isMobile ? 4 : 8
        };

        if (DEV_CONFIG.enableConsoleLog) {
            console.log('üéÆ Device Profile:', { isMobile, isLowEnd, performanceSettings });
            console.log('üõ†Ô∏è Dev Features:', DEV_CONFIG);
        }

        // Three.js Setup
        const canvas = document.getElementById('gameCanvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({
            canvas,
            antialias: performanceSettings.antialias,
            powerPreference: isMobile ? 'low-power' : 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(pixelRatio);
        renderer.shadowMap.enabled = performanceSettings.shadowsEnabled;
        if (performanceSettings.shadowsEnabled) {
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x2a1810, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xff6b35, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Add atmospheric diya lights (scaled for performance)
        const diyaLights = [];
        const lightCount = Math.min(performanceSettings.maxLights, 6);
        for (let i = 0; i < lightCount; i++) {
            const light = new THREE.PointLight(0xffaa00, isMobile ? 0.4 : 0.6, isMobile ? 6 : 8);
            light.position.set((i - (lightCount - 1) / 2) * 3, 1.5, -5 - i * 3);
            if (performanceSettings.shadowsEnabled) {
                light.castShadow = true;
                light.shadow.mapSize.width = 512;
                light.shadow.mapSize.height = 512;
            }
            scene.add(light);
            diyaLights.push(light);
        }

        // Game Objects
        let player, obstacles = [], collectibles = [];
        let spawnTimer = 0, spawnInterval = 2.5;

        // üõ†Ô∏è Development Features
        class DevTools {
            constructor() {
                this.fps = 0;
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fpsUpdateInterval = DEV_CONFIG.fpsUpdateRate; // Real-time updates
                this.lastFpsUpdate = performance.now();
                this.isVisible = false;
                this.frameTime = 0;
                this.maxFPS = 120; // Cap FPS display at 120

                // For real-time FPS calculation
                this.frameTimes = [];
                this.maxFrameTimesSamples = 60; // Sample last 60 frames for smooth FPS
                
                // Memory tracking for leak detection
                this.memoryHistory = [];
                this.maxMemoryHistory = 100; // Keep last 100 memory samples

                this.initDevPanel();
            }

            initDevPanel() {
                if (!DEV_CONFIG.showFPS && !DEV_CONFIG.showStats) return;

                // Show dev elements
                document.getElementById('devToggle').style.display = 'block';
                if (DEV_CONFIG.showFPS || DEV_CONFIG.showStats) {
                    document.getElementById('devPanel').style.display = 'block';
                    this.isVisible = true;
                }

                // Toggle functionality
                document.getElementById('devToggle').addEventListener('click', () => {
                    this.togglePanel();
                });

                // Keyboard shortcuts for dev features
                document.addEventListener('keydown', (event) => {
                    if (event.key === 'F3') {
                        event.preventDefault();
                        this.togglePanel();
                    }
                    if (event.key === 'F4') {
                        event.preventDefault();
                        DEV_CONFIG.godMode = !DEV_CONFIG.godMode;
                        console.log(`üõ°Ô∏è God Mode: ${DEV_CONFIG.godMode ? 'ON' : 'OFF'}`);
                    }
                });

                // Update device profile
                document.getElementById('deviceProfile').textContent =
                    `${isMobile ? 'Mobile' : 'Desktop'} ${isLowEnd ? 'Low' : 'High'}`;
            }

            update(currentTime) {
                // Calculate frame time
                const deltaTime = currentTime - this.lastTime;
                this.frameTime = deltaTime;
                this.lastTime = currentTime;

                // Add to frame times array for smooth FPS calculation
                this.frameTimes.push(deltaTime);
                if (this.frameTimes.length > this.maxFrameTimesSamples) {
                    this.frameTimes.shift();
                }

                // Calculate real-time FPS from average frame time
                if (this.frameTimes.length > 0) {
                    const avgFrameTime = this.frameTimes.reduce((a, b) => a + b) / this.frameTimes.length;
                    this.fps = Math.min(Math.round(1000 / avgFrameTime), this.maxFPS);
                }

                // Update display at specified interval
                if (currentTime - this.lastFpsUpdate >= this.fpsUpdateInterval) {
                    this.lastFpsUpdate = currentTime;

                    if (this.isVisible && DEV_CONFIG.showFPS) {
                        this.updateFPSDisplay();
                    }

                    if (this.isVisible && DEV_CONFIG.showStats) {
                        this.updateStatsDisplay();
                    }
                }

                // Log performance warnings
                if (DEV_CONFIG.enableConsoleLog && this.fps > 0 && this.fps < 30) {
                    console.warn(`‚ö†Ô∏è Low FPS detected: ${this.fps}`);
                }
            }

            updateFPSDisplay() {
                const fpsValueElement = document.getElementById('fpsValue');
                const fpsFillElement = document.getElementById('fpsFill');
                const frameTimeElement = document.getElementById('frameTime');

                if (fpsValueElement && fpsFillElement) {
                    // Update FPS value with color coding
                    const cappedFPS = Math.min(this.fps, this.maxFPS);
                    fpsValueElement.textContent = cappedFPS;

                    // Color coding based on FPS
                    let color;
                    if (cappedFPS >= 60) {
                        color = '#00ff88'; // Green for 60+ FPS
                    } else if (cappedFPS >= 30) {
                        color = '#ffaa00'; // Yellow for 30-59 FPS
                    } else {
                        color = '#ff4444'; // Red for <30 FPS
                    }
                    fpsValueElement.style.color = color;

                    // Update FPS bar (percentage of 120 FPS)
                    const percentage = (cappedFPS / this.maxFPS) * 100;
                    fpsFillElement.style.width = `${percentage}%`;

                    // Update frame time
                    if (frameTimeElement) {
                        frameTimeElement.textContent = this.frameTime.toFixed(1);
                    }
                }
            }

            togglePanel() {
                this.isVisible = !this.isVisible;
                document.getElementById('devPanel').style.display = this.isVisible ? 'block' : 'none';

                if (DEV_CONFIG.enableConsoleLog) {
                    console.log(`üõ†Ô∏è Dev Panel: ${this.isVisible ? 'SHOWN' : 'HIDDEN'}`);
                }
            }

            updateStatsDisplay() {
                // Count objects
                const objectCount = obstacles.length + collectibles.length + 1; // +1 for player
                document.getElementById('objectCount').textContent = objectCount;

                // Estimate triangle count
                const triangleCount = this.estimateTriangleCount();
                document.getElementById('triangleCount').textContent = triangleCount;

                // Real-time memory usage (if available)
                if (performance.memory) {
                    const used = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    const total = Math.round(performance.memory.totalJSHeapSize / 1024 / 1024);
                    const limit = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
                    
                    // Show used/total with color coding based on usage percentage
                    const usagePercent = (used / limit) * 100;
                    let memoryColor = '#00ff88'; // Green
                    if (usagePercent > 80) memoryColor = '#ff4444'; // Red
                    else if (usagePercent > 60) memoryColor = '#ffaa00'; // Yellow
                    
                    const memoryElement = document.getElementById('memoryUsage');
                    memoryElement.textContent = `${used}/${total}MB`;
                    memoryElement.style.color = memoryColor;
                    
                    // Track memory history for leak detection
                    this.memoryHistory.push(used);
                    if (this.memoryHistory.length > this.maxMemoryHistory) {
                        this.memoryHistory.shift();
                    }
                    
                    // Check for memory leaks (if memory consistently increases)
                    if (this.memoryHistory.length >= 50) {
                        const recent = this.memoryHistory.slice(-10).reduce((a, b) => a + b) / 10;
                        const older = this.memoryHistory.slice(-50, -40).reduce((a, b) => a + b) / 10;
                        const increase = recent - older;
                        
                        if (increase > 5 && DEV_CONFIG.enableConsoleLog) { // 5MB increase
                            console.warn(`üö® Potential memory leak detected: +${increase.toFixed(1)}MB`);
                        }
                    }
                } else {
                    document.getElementById('memoryUsage').textContent = 'N/A';
                }
            }

            estimateTriangleCount() {
                let triangles = 0;

                // Player: CapsuleGeometry approximation
                triangles += isMobile ? 36 : 64;

                // Obstacles: BoxGeometry
                triangles += obstacles.length * 12;

                // Collectibles: varies by type
                collectibles.forEach(collectible => {
                    switch (collectible.type) {
                        case 'coin': triangles += isMobile ? 24 : 48; break;
                        case 'diya': triangles += isMobile ? 24 : 32; break;
                        case 'sparkler': triangles += isMobile ? 12 : 18; break;
                        case 'rangoli': triangles += isMobile ? 24 : 32; break;
                        default: triangles += 24;
                    }
                });

                return triangles;
            }

            logGameEvent(event, data = {}) {
                if (DEV_CONFIG.enableConsoleLog) {
                    console.log(`üéÆ ${event}:`, data);
                }
            }

            getFPS() {
                return this.fps;
            }
        }

        const devTools = new DevTools();

        // Scalable Asset Definitions
        const AssetScale = {
            player: isMobile ? 0.8 : 1.0,
            obstacle: isMobile ? 0.9 : 1.0,
            collectible: isMobile ? 0.8 : 1.0,
            lane: isMobile ? 1.5 : 2.0
        };

        // Player Class
        class Player {
            constructor() {
                const geometry = new THREE.CapsuleGeometry(
                    0.3 * AssetScale.player,
                    1.2 * AssetScale.player,
                    isMobile ? 3 : 4,
                    isMobile ? 6 : 8
                );
                const material = new THREE.MeshStandardMaterial({
                    color: 0xff6b35,
                    emissive: 0x331100,
                    roughness: 0.3,
                    metalness: 0.1
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(0, 0.6 * AssetScale.player, 0);
                this.mesh.castShadow = performanceSettings.shadowsEnabled;
                this.mesh.receiveShadow = performanceSettings.shadowsEnabled;

                this.velocity = new THREE.Vector3(0, 0, 0);
                this.lanes = [-AssetScale.lane, 0, AssetScale.lane];
                this.currentLane = 1;
                this.targetX = 0;
                this.isGrounded = true;
                this.jumpForce = isMobile ? 12 : 15;
                this.gravity = isMobile ? -40 : -50;
                this.moveSpeed = isMobile ? 6 : 8;

                scene.add(this.mesh);
            }

            jump() {
                if (this.isGrounded) {
                    this.velocity.y = this.jumpForce;
                    this.isGrounded = false;
                }
            }

            moveLeft() {
                if (this.currentLane > 0) {
                    this.currentLane--;
                    this.targetX = this.lanes[this.currentLane];
                }
            }

            moveRight() {
                if (this.currentLane < this.lanes.length - 1) {
                    this.currentLane++;
                    this.targetX = this.lanes[this.currentLane];
                }
            }

            update(deltaTime) {
                // Lane switching
                const dx = this.targetX - this.mesh.position.x;
                if (Math.abs(dx) > 0.1) {
                    this.mesh.position.x += dx * this.moveSpeed * deltaTime;
                } else {
                    this.mesh.position.x = this.targetX;
                }

                // Jumping and gravity
                if (!this.isGrounded) {
                    this.velocity.y += this.gravity * deltaTime;
                    this.mesh.position.y += this.velocity.y * deltaTime;

                    if (this.mesh.position.y <= 0.6) {
                        this.mesh.position.y = 0.6;
                        this.velocity.y = 0;
                        this.isGrounded = true;
                    }
                }

                // Running animation
                this.mesh.rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
            }
        }

        // Obstacle Class
        class Obstacle {
            constructor(lane, z) {
                const scale = AssetScale.obstacle;
                const geometry = new THREE.BoxGeometry(0.8 * scale, 1.5 * scale, 0.8 * scale);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8b0000,
                    emissive: 0x330000,
                    roughness: 0.4
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(this.lanes[lane], 0.75 * scale, z);
                this.mesh.castShadow = performanceSettings.shadowsEnabled;
                this.mesh.receiveShadow = performanceSettings.shadowsEnabled;
                this.velocity = gameState.speed;

                // Add warning glow for mobile visibility
                if (isMobile) {
                    const glowGeometry = new THREE.BoxGeometry(1.2 * scale, 1.8 * scale, 1.2 * scale);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: 0xff4444,
                        transparent: true,
                        opacity: 0.2,
                        wireframe: true
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.mesh.add(glow);
                }

                scene.add(this.mesh);
            }

            get lanes() { return [-AssetScale.lane, 0, AssetScale.lane]; }

            update(deltaTime) {
                this.mesh.position.z += this.velocity * deltaTime;
                this.mesh.rotation.y += 2 * deltaTime;
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Collectible Class
        class Collectible {
            constructor(lane, z, type = null) {
                const types = ['coin', 'diya', 'sparkler', 'rangoli'];
                this.type = type || types[Math.floor(Math.random() * types.length)];

                const scale = AssetScale.collectible;
                let geometry, material;

                switch (this.type) {
                    case 'diya':
                        geometry = new THREE.CylinderGeometry(
                            0.2 * scale, 0.3 * scale, 0.15 * scale,
                            isMobile ? 6 : 8
                        );
                        material = new THREE.MeshStandardMaterial({
                            color: 0xffaa00,
                            emissive: 0x442200,
                            roughness: 0.3
                        });
                        break;
                    case 'sparkler':
                        geometry = new THREE.ConeGeometry(
                            0.05 * scale, 0.8 * scale,
                            isMobile ? 4 : 6
                        );
                        material = new THREE.MeshStandardMaterial({
                            color: 0xff6b35,
                            emissive: 0x331100,
                            roughness: 0.2
                        });
                        break;
                    case 'rangoli':
                        geometry = new THREE.RingGeometry(
                            0.2 * scale, 0.4 * scale,
                            isMobile ? 6 : 8
                        );
                        material = new THREE.MeshStandardMaterial({
                            color: 0xff1493,
                            emissive: 0x330033,
                            transparent: true,
                            opacity: 0.8,
                            roughness: 0.1
                        });
                        break;
                    default: // coin
                        geometry = new THREE.SphereGeometry(
                            0.3 * scale,
                            isMobile ? 6 : 8,
                            isMobile ? 4 : 6
                        );
                        material = new THREE.MeshStandardMaterial({
                            color: 0xffdd00,
                            emissive: 0x443300,
                            metalness: 0.8,
                            roughness: 0.2
                        });
                }

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(this.lanes[lane], 1 * scale, z);
                this.mesh.castShadow = performanceSettings.shadowsEnabled;
                this.velocity = gameState.speed;

                // Add glow effect for better visibility
                if (isMobile) {
                    const glowColors = {
                        coin: 0xffdd00,
                        diya: 0xffaa00,
                        sparkler: 0xff6b35,
                        rangoli: 0xff1493
                    };

                    const glowGeometry = geometry.clone();
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: glowColors[this.type],
                        transparent: true,
                        opacity: 0.3,
                        wireframe: true
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.scale.setScalar(1.3);
                    this.mesh.add(glow);
                }

                scene.add(this.mesh);
            }

            get lanes() { return [-AssetScale.lane, 0, AssetScale.lane]; }

            update(deltaTime) {
                this.mesh.position.z += this.velocity * deltaTime;
                this.mesh.position.y = 1 + Math.sin(Date.now() * 0.005 + this.mesh.position.z) * 0.2;
                this.mesh.rotation.y += 3 * deltaTime;

                // Special animations
                if (this.type === 'sparkler') {
                    this.mesh.rotation.z += 5 * deltaTime;
                } else if (this.type === 'rangoli') {
                    const scale = 1 + 0.1 * Math.sin(Date.now() * 0.01);
                    this.mesh.scale.setScalar(scale);
                }
            }

            getValue() {
                const values = { coin: 10, diya: 25, sparkler: 15, rangoli: 30 };
                return values[this.type] || 10;
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        // Create Ground
        function createGround() {
            // Main ground (scaled for different screen sizes)
            const groundWidth = isMobile ? 15 : 20;
            const groundGeometry = new THREE.PlaneGeometry(groundWidth, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a1810,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = performanceSettings.shadowsEnabled;
            scene.add(ground);

            // Lane markers (responsive spacing)
            const laneSpacing = AssetScale.lane;
            for (let i = 0; i < 4; i++) {
                const lineGeometry = new THREE.BoxGeometry(
                    isMobile ? 0.08 : 0.1,
                    0.02,
                    100
                );
                const lineMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffaa00,
                    emissive: 0x221100
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(-laneSpacing * 1.5 + i * laneSpacing, 0.01, 0);
                scene.add(line);
            }

            // Decorative diyas (fewer on mobile for performance)
            const diyaCount = isMobile ? 10 : 15;
            const diyaSpacing = isMobile ? 5 : 4;

            for (let i = 0; i < diyaCount; i++) {
                const z = -30 + i * diyaSpacing;
                const sideDistance = isMobile ? 3.5 : 4.5;

                [-sideDistance, sideDistance].forEach(x => {
                    const diyaScale = isMobile ? 0.7 : 1.0;
                    const diyaGeometry = new THREE.CylinderGeometry(
                        0.1 * diyaScale,
                        0.15 * diyaScale,
                        0.08 * diyaScale,
                        isMobile ? 4 : 6
                    );
                    const diyaMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffaa00,
                        emissive: 0x442200,
                        roughness: 0.3
                    });
                    const diya = new THREE.Mesh(diyaGeometry, diyaMaterial);
                    diya.position.set(x, 0.04 * diyaScale, z);
                    diya.castShadow = performanceSettings.shadowsEnabled;
                    scene.add(diya);
                });
            }
        }

        // Game Functions
        function startGame() {
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.gameOver = false;
            gameState.score = 0;
            gameState.speed = 10;
            gameState.lives = 3;
            spawnTimer = 0;
            spawnInterval = 2.5;

            // Clear objects
            obstacles.forEach(obs => obs.dispose());
            collectibles.forEach(col => col.dispose());
            obstacles = [];
            collectibles = [];

            // Show game UI
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('gameStats').style.display = 'block';
            document.getElementById('gameControls').style.display = 'flex';

            updateUI();
        }

        function pauseGame() {
            gameState.isPaused = !gameState.isPaused;
            document.getElementById('pauseBtn').textContent = gameState.isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        }

        function gameOver() {
            gameState.gameOver = true;
            gameState.isPlaying = false;

            // Update high score
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('diwaliRunnerHighScore', gameState.highScore.toString());
            }

            // Show game over screen
            document.getElementById('finalScore').textContent = `Final Score: ${gameState.score}`;
            document.getElementById('gameOverScreen').style.display = 'block';
            document.getElementById('gameStats').style.display = 'none';
            document.getElementById('gameControls').style.display = 'none';
        }

        function spawnObjects() {
            const lanes = [0, 1, 2];
            const availableLanes = [...lanes];

            // Spawn obstacles
            const obstacleCount = Math.random() < 0.7 ? 1 : 2;
            for (let i = 0; i < obstacleCount && availableLanes.length > 0; i++) {
                const laneIndex = Math.floor(Math.random() * availableLanes.length);
                const lane = availableLanes.splice(laneIndex, 1)[0];
                obstacles.push(new Obstacle(lane, -50));
            }

            // Spawn collectibles
            availableLanes.forEach(lane => {
                if (Math.random() < 0.8) {
                    collectibles.push(new Collectible(lane, -50));
                }
            });
        }

        function checkCollisions() {
            const playerPos = player.mesh.position;

            // Scaled collision distances for different screen sizes
            const obstacleCollisionDistance = isMobile ? 0.9 : 1.0;
            const collectibleCollisionDistance = isMobile ? 0.9 : 0.8;

            // Check obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const distance = playerPos.distanceTo(obstacle.mesh.position);

                if (distance < obstacleCollisionDistance) {
                    gameState.lives--;

                    // Visual collision effect
                    createCollisionEffect(obstacle.mesh.position);

                    obstacle.dispose();
                    obstacles.splice(i, 1);

                    // Haptic feedback for collision
                    if (navigator.vibrate) {
                        navigator.vibrate([100, 50, 100]);
                    }

                    if (gameState.lives <= 0) {
                        gameOver();
                        return;
                    }
                }
            }

            // Check collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                const distance = playerPos.distanceTo(collectible.mesh.position);

                if (distance < collectibleCollisionDistance) {
                    gameState.score += collectible.getValue();

                    // Visual pickup effect
                    createPickupEffect(collectible.mesh.position, collectible.type);

                    collectible.dispose();
                    collectibles.splice(i, 1);

                    // Haptic feedback for pickup
                    if (navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                }
            }
        }

        // Visual Effects Functions
        function createCollisionEffect(position) {
            if (!performanceSettings.particleCount) return;

            const particleCount = Math.floor(20 * performanceSettings.particleCount);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = position.x + (Math.random() - 0.5) * 2;
                positions[i3 + 1] = position.y + Math.random() * 2;
                positions[i3 + 2] = position.z + (Math.random() - 0.5) * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: isMobile ? 3 : 4,
                color: 0xff4444,
                transparent: true,
                opacity: 1.0
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Animate and remove
            let opacity = 1.0;
            const animate = () => {
                opacity -= 0.05;
                material.opacity = opacity;

                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            };
            animate();
        }

        function createPickupEffect(position, type) {
            if (!performanceSettings.particleCount) return;

            const colors = {
                coin: 0xffdd00,
                diya: 0xffaa00,
                sparkler: 0xff6b35,
                rangoli: 0xff1493
            };

            const particleCount = Math.floor(15 * performanceSettings.particleCount);
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                positions[i3] = position.x + (Math.random() - 0.5);
                positions[i3 + 1] = position.y + Math.random();
                positions[i3 + 2] = position.z + (Math.random() - 0.5);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                size: isMobile ? 2 : 3,
                color: colors[type] || 0xffffff,
                transparent: true,
                opacity: 1.0
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Animate and remove
            let opacity = 1.0;
            const animate = () => {
                opacity -= 0.08;
                material.opacity = opacity;
                particles.position.y += 0.05;

                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(particles);
                    geometry.dispose();
                    material.dispose();
                }
            };
            animate();
        }

        function updateUI() {
            document.getElementById('score').textContent = `üéÜ Score: ${gameState.score}`;
            document.getElementById('lives').textContent = `‚ù§Ô∏è Lives: ${gameState.lives}`;
            document.getElementById('speed').textContent = `‚ö° Speed: ${Math.floor(gameState.speed)}`;
        }

        // Controls
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (event) => {
                if (!gameState.isPlaying || gameState.isPaused) return;

                switch (event.code) {
                    case 'Space':
                    case 'ArrowUp':
                        event.preventDefault();
                        player.jump();
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        event.preventDefault();
                        player.moveLeft();
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        event.preventDefault();
                        player.moveRight();
                        break;
                }
            });

            // Enhanced Touch controls with haptic feedback
            function addTouchControl(elementId, action) {
                const element = document.getElementById(elementId);

                const handleTouch = (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    if (gameState.isPlaying && !gameState.isPaused) {
                        action();

                        // Haptic feedback on supported devices
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }

                        // Visual feedback
                        element.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            element.style.transform = 'scale(1)';
                        }, 100);
                    }
                };

                element.addEventListener('touchstart', handleTouch, { passive: false });
                element.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    element.style.transform = 'scale(1)';
                }, { passive: false });
            }

            addTouchControl('jumpArea', () => player.jump());
            addTouchControl('moveLeft', () => player.moveLeft());
            addTouchControl('moveRight', () => player.moveRight());

            // UI Buttons
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('pauseBtn').addEventListener('click', pauseGame);
            document.getElementById('restartBtn').addEventListener('click', () => {
                startGame();
            });
        }

        // Game Loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);

            // üõ†Ô∏è Update development tools (FPS counter, etc.)
            devTools.update(currentTime);

            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Animate diya lights
            const time = Date.now() * 0.001;
            diyaLights.forEach((light, index) => {
                const flicker = 0.4 + 0.2 * Math.sin(time * 3 + index * Math.PI);
                light.intensity = flicker;
            });

            if (gameState.isPlaying && !gameState.isPaused && !gameState.gameOver) {
                // Update player
                player.update(deltaTime);

                // Update obstacles
                obstacles.forEach((obstacle, index) => {
                    obstacle.update(deltaTime);
                    if (obstacle.mesh.position.z > 10) {
                        obstacle.dispose();
                        obstacles.splice(index, 1);
                    }
                });

                // Update collectibles
                collectibles.forEach((collectible, index) => {
                    collectible.update(deltaTime);
                    if (collectible.mesh.position.z > 10) {
                        collectible.dispose();
                        collectibles.splice(index, 1);
                    }
                });

                // Spawn objects
                spawnTimer += deltaTime;
                if (spawnTimer >= spawnInterval) {
                    spawnObjects();
                    spawnTimer = 0;
                    gameState.speed += 0.1;
                    spawnInterval = Math.max(1.5, spawnInterval - 0.02);
                }

                // Check collisions
                checkCollisions();

                // Update score
                gameState.score += Math.floor(deltaTime * 5);

                // Update UI
                updateUI();
            }

            renderer.render(scene, camera);
        }

        // Enhanced Resize handler with orientation support
        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);

            // Adjust camera position for different aspect ratios
            if (width / height < 0.7) { // Portrait mobile
                camera.position.set(0, 4, 10);
                camera.fov = 80;
            } else if (width / height > 1.8) { // Wide landscape
                camera.position.set(0, 2.5, 7);
                camera.fov = 70;
            } else { // Standard
                camera.position.set(0, 3, 8);
                camera.fov = 75;
            }

            camera.updateProjectionMatrix();

            console.log(`üì± Resized: ${width}x${height}, aspect: ${(width / height).toFixed(2)}`);
        }

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('orientationchange', () => {
            setTimeout(onWindowResize, 100); // Delay for orientation change
        });

        // Initialize
        function init() {
            createGround();
            player = new Player();
            setupControls();
            animate(performance.now());
            console.log('ü™î Diwali Night Runner ready!');
        }

        // Start the game
        init();
    </script>
</body>

</html>